<html>
  <head>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.1.9/lib/p5.js"></script>
    <script>
let input, button, greeting;

function setup() {
  // create canvas
  createCanvas(0, 0);

  input1 = createInput();
  input1.position(20, 65);
  input1.value(5)
  input2 = createInput();
  input2.value(2)
  input2.position(20, 105);

  button = createButton('submit');
  button.position(input1.x + input1.width+20, 65);
  button.mousePressed(greet);

  greeting = createElement('h2', 'Simplex solver (with Big M)');
  greeting.position(20, 155);

  textAlign(CENTER);
  textSize(50);
}

let x=0,y=0
let ok
function greet() {
    
    x = parseInt(input1.value())
    y = parseInt(input2.value())
    if(!isNaN(x)&&!isNaN(y)){
        input1.remove();input2.remove();greeting.remove();button.remove()
        ok = createButton('start')
        ok.mousePressed(()=>{solvefor()});
        start()
    } else {
        // greeting.html('Rezolvarea problemelor de min/max cu metoda Simplex')
    }

}

let inputs = []
let cos = []
let cbs = []
let pos = []
let ois = []
let ress = []
let fos
let os = {x:100,y:100}
let str = ''
function start(){
    let ocon = console.log
    console.log = (...args)=>{
        str+='<br>'
        args.forEach(e=>{
            str+='<br>'+e
        })
        greeting.html(str)
        ocon(...args)
    }
    greeting = createElement('h5', '');
    greeting.position(360, 25);
    for (let j = 0; j < y; j++) {
        inputs.push([])
        for (let i = 0; i < x; i++) {
            inputs[inputs.length-1].push(createInput().size(30,30).position(os.x+i*30,os.y+j*30))
        }
        
    }

    for (let i = 0; i < x; i++) {
        cos.push(createInput().size(30,30).position(os.x+i*30,os.y-30).attribute('placeholder', 'co'))
    }
    for (let i = 0; i < y; i++) {
        cbs.push(createInput().size(30,30).position(os.x-60,os.y+i*30).attribute('placeholder', 'cb'))
    }
    for (let i = 0; i < y; i++) {
        pos.push(createInput().size(30,30).position(os.x-30,os.y+i*30).attribute('placeholder', 'po'))
    }

    for (let i = 0; i < y; i++) {
        ois.push(createInput().size(30,30).position(os.x+30*x,os.y+i*30).attribute('placeholder', 'oi').attribute('disabled', 'true'))
    }
    for (let i = 0; i < x; i++) {
        ress.push(createInput().size(30,30).position(os.x+i*30,os.y+y*30).attribute('placeholder', 'r').attribute('disabled', 'true'))
    }
    fos = createInput().size(30,30).position(os.x-30,os.y+y*30).attribute('placeholder', 'fx').attribute('disabled', 'true')
    
}
let base = [0,0]
function solvefor(){
   
        let m = []
        let co = []
        let cb = []
        let po = []
        inputs.forEach(e=>{
            m.push([])
            e.forEach(j=>{
                m[m.length-1].push(parseFloat(j.value()))
            })
        })

        cos.forEach(e=>{
            co.push(parseFloat(e.value()))
        })
        cbs.forEach(e=>{
            cb.push(parseFloat(e.value()))
        })
        pos.forEach(e=>{
            po.push(parseFloat(e.value()))
        })
        console.log(m)
        console.log(co)
        console.log(cb)
        console.log(po)
        simplex(m,cb,po,co,1,[],[],[])
    
}

function showStep(oss,arr,cb,po,co,res,oix,fox){
    
    let inputs = []
    let cos = []
    let cbs = []
    let pos = []
    let ois = []
    let ress = []
    let fos
    for (let j = 0; j < y; j++) {
        inputs.push([])
        for (let i = 0; i < x; i++) {
            inputs[inputs.length-1].push(createInput().size(30,30).position(oss.x+i*30,oss.y+j*30).value(arr[j][i]))
        }
        
    }

    for (let i = 0; i < x; i++) {
        cos.push(createInput().size(30,30).position(oss.x+i*30,os.y-30).attribute('placeholder', 'co').attribute('disabled', 'true').value(co[i]))
    }
    for (let i = 0; i < y; i++) {
        cbs.push(createInput().size(30,30).position(oss.x-60,oss.y+i*30).attribute('placeholder', 'cb').attribute('disabled', 'true').value(cb[i]))
    }
    for (let i = 0; i < y; i++) {
        pos.push(createInput().size(30,30).position(oss.x-30,oss.y+i*30).attribute('placeholder', 'po').attribute('disabled', 'true').value(po[i]))
    }

    for (let i = 0; i < y; i++) {
        ois.push(createInput().size(30,30).position(oss.x+30*x,oss.y+i*30).attribute('placeholder', 'oi').attribute('disabled', 'true').value(oix[i]))
    }
    for (let i = 0; i < x; i++) {
        ress.push(createInput().size(30,30).position(oss.x+i*30,oss.y+y*30).attribute('placeholder', 'r').attribute('disabled', 'true').value(res[i]))
    }
    fos = createInput().size(30,30).position(oss.x-30,oss.y+y*30).attribute('placeholder', 'fx').attribute('disabled', 'true').value(fox)
}</script>
    <script>


//----------------Simplex Solver by Cunev S.Dmitri----------------
// Table solving reproduction

let transpose = m => m[0].map((x,i) => m.map(x => x[i]))

// let cb = [0,0]
// let po = [10,8]
// let co = [2,-1,-3,0,0]
// let arr = [
//     [1,1,2,1,0],
//     [3,-1,2,0,1]
// ]
// let base = [4,5]
function simplex(arr,cb,po,co,n,ress,oix,fox){
    
        
    
    console.log(`\n\n====================Iteration ${n}====================`)
    let res = []


    let tarr = []
    let oi = []
    arr.forEach((r,j)=>{
        tarr.push([])
        r.forEach(e=>{
            tarr[tarr.length-1].push(e*cb[j])
        })
    })
    tarr = transpose(tarr)
    tarr.forEach((e,i)=>{
        let sum = 0
        e.forEach(el=>{
            sum+=el
        })
        sum=sum-co[i]
        res.push(sum)
    })
    let fxo = 0
    po.forEach((e,i)=>{
        fxo+=e*cb[i]
    })

    console.log(`fxo: ${fxo}`)
    console.log(`res: ${res}`)

    let contin = false;
    let max = 0
    let maxindex = 0
    res.forEach((e,i)=>{
        if(e>0){
            contin = true
            if(e>max) {max = e;maxindex = i}
        }
    })
    if(contin){
        console.log(`Found positive res, continuing at index ${maxindex+1} with value ${max}; \nCalculating Oi`)
        let arrt = transpose(arr)
        let maxrow = arrt[maxindex]
        arrt[maxindex].forEach((e,i)=>{if(e===0){console.log('Division by 0, something went wrong')} else {oi.push(po[i]/e)}})
        let mino = Infinity;
        let minoi = -1
        oi.forEach((e,i)=>{
            if(e>0){
                if(mino>e){
                    mino = e
                    minoi = i
                }
            }
        })
        console.log(oi)
        if(minoi!=-1){
            console.log(`Found smallest positive oi, ${mino} at index ${minoi+1}`)
            console.log(`\n> The next pivot would be ${arr[minoi][maxindex]} at [${minoi+1},${maxindex+1}]`)
            console.log(`\n> Reducing row [${maxrow}] with pivot at index ${minoi+1}`)
            let pivot = arr[minoi][maxindex]
            let pivotp = {y:minoi,x:maxindex}
            lpivot = pivotp
            let rarr = []
            let opo = []
            maxrow.forEach((r,i)=>{
                if(i!=minoi){
                    rarr.push([])
                    let deltaval = -(r/pivot)
                    console.log(`<OP> Adding L${pivotp.y+1}*${deltaval} to ${i+1}`)
                    opo.push(po[i]+po[pivotp.y]*deltaval)
                    arr[pivotp.y].forEach((e,j)=>{
                        rarr[rarr.length-1].push(e*deltaval+arr[i][j])
                    })
                } else {
                    rarr.push([])
                    opo.push(po[i]*(1/arr[minoi][maxindex]))
                    arr[pivotp.y].forEach((e,j)=>{
                        rarr[rarr.length-1].push(e*(1/arr[minoi][maxindex]))
                    })
                }
                
            })
    
            console.log(`<OP> Multiplying line ${minoi+1} by 1/${arr[minoi][maxindex]}`)
    
            console.log('\n\n')
            console.log(rarr)
            console.log(`New PO = ${opo}`)
            showStep({x:100,y:((y+2)*30)*(n+1)},arr,cb,po,co,res,oi,fxo)
            console.log(`\n<INSERT> CO: ${co[pivotp.x]} to Cb index ${pivotp.y}`)
            base[pivotp.y] = pivotp.x+1
            cb[pivotp.y] = co[pivotp.x]
            console.log(cb)

            console.log('Repeating algorithm, next path ->')
            
            simplex(rarr,cb,opo,co,n+1,res,oi,fxo)
            
            // 
    
        } else {
            console.log(`No positives found, aborting.`)
            showStep({x:100,y:((y+2)*30)*(n+1)},arr,cb,po,co,res,oi,fxo)
        }
    } else {
        console.log('\n\n[SUCCESS] Stopped algorithm, found solution.')
        console.log(`>Po: ${po}`)
        console.log(`>Cb: ${cb}`)
        // console.log(`With main variables ${base}`)
        let optisol = []
        co.forEach((e,i)=>{
            optisol.push(0)
        })
        base.forEach((e,i)=>{
            optisol[e-1] = po[i]
        })
        // console.log(`x.opt = `,optisol)
        showStep({x:100,y:((y+2)*30)*(n+1)},arr,cb,po,co,res,oi,fxo)

    }
   
}
// simplex(arr,cb,po,co,1)</script>
    <style>
    
    </style>
  </head>
  <body>
    <main>
    </main>
  </body>
</html>
